<script src="../js/test.js"></script>
<script src="../js/defs.js"></script>
<script src="../js/fs_helper.js"></script>
<script src="../js/fs.js"></script>
<script src="../js/myfs.js"></script>
<script src="../js/lfs.js"></script>
<script>

async function test_layered_fns() {
  function TestFS() {};
  inherit(TestFS, DefaultFS);
  function _gen_TestFS_attr(attr) {
    return "TestFS.prototype." + attr + "= function() { " +
      "this." + attr + "_called = arguments;" +
      "};";
  }

  var ignore = new Set(["constructor", "mount", "umount", "seek"]);
  var callbacks = Object.getOwnPropertyNames(DefaultFS.prototype).filter(x => !ignore.has(x));
  for (name of callbacks) {
    if (name === "constructor")
      continue;
    eval(_gen_TestFS_attr(name));
  }
  console.log(TestFS);

  var testfs = new TestFS();
  var lfs = new LayeredFilesystem();
  await lfs.mkdir("/test", 0o755);
  await lfs.mount("/test", testfs);

  lfs.readdir("/test");
  assert(testfs.readdir_called && testfs.readdir_called[0] == "/", testfs);

  lfs.stat("/test/newfile");
  assert(testfs.stat_called && testfs.stat_called[0] == "/newfile");

  lfs.unlink("/test/newfile");
  assert(testfs.unlink_called && testfs.unlink_called[0] == "/newfile");

  lfs.create("/test/newfile", 0);
  assert(
    testfs.create_called &&
    testfs.create_called[0] == "/newfile" &&
    testfs.create_called[1] == 0);

  lfs.truncate("/test/newfile", 0);
  assert(testfs.truncate_called && testfs.truncate_called[0] == "/newfile");

  lfs.chmod("/test", 0o777);
  assert(
    testfs.chmod_called &&
    testfs.chmod_called[0] == "/" &&
    testfs.chmod_called[1] == 0o777);

  lfs.link("/test/newfile", "/test/newfile1");
  assert(
    testfs.link_called &&
    testfs.link_called[0] == "/newfile" &&
    testfs.link_called[1] == "/newfile1")

  lfs.mkdir("/test/newdir")
  assert(testfs.mkdir_called && testfs.mkdir_called[0] == "/newdir");

  lfs.open("/test", O_RDONLY);
  assert(testfs.open_called && testfs.open_called[0] == "/");

  var fd = new FileDescriptor(testfs, "", 0, null, 0);
  lfs.ioctl(fd, 0, null);
  assert(
    testfs.ioctl_called &&
    testfs.ioctl_called[0] == fd &&
    testfs.ioctl_called[1] == 0 &&
    testfs.ioctl_called[2] == null);


  lfs.close(fd)
  assert(testfs.close_called && testfs.close_called[0] == fd);

  var data = new Uint8Array([1, 2, 3, 4, 5]);
  lfs.write(fd, data);
  assert(
    testfs.write_called &&
    testfs.write_called[0] == fd &&
    testfs.write_called[1] == data);

  lfs.read(fd, data);
  assert(
    testfs.read_called &&
    testfs.read_called[0] == fd &&
    testfs.read_called[1] == data)
  return lfs;
}

async function test_layered_mounts() {
    var lfs = new LayeredFilesystem();
    var tmp = new MyFS();
    await lfs.mkdir("/tmp", 0o777);
    await lfs.mount("/tmp", tmp);

    await lfs.create("/asdf", 0o777);
    assert((await lfs.readdir("/")).length == 4);
    console.log(await lfs.readdir("/tmp"));
    assert((await lfs.readdir("/tmp")).length == 2);

    await lfs.create("/tmp/asdf", 0o777);
    assert((await lfs.readdir("/tmp")).length == 3);
	console.log((await tmp.readdir("/")));
    assert((await tmp.readdir("/")).length == 3);
	return lfs;
}

async function test_readdir() {
    var fs = new MyFS();
    assert((await fs.readdir("/")).length == 2);
    await fs.open("/asdf", O_CREAT, 0o777);
    assert((await fs.readdir("/")).length == 3);
    return fs;
}

async function test_write(){
    fs = new MyFS();
    console.log((await fs.readdir("/")).length == 2);
    await fs.open("/asdf", O_CREAT, 0o777);
    file = await fs.open("/asdf", O_WRONLY);
    console.log(file);
    buffer = new ArrayBuffer(32);
    data = new Uint8Array(buffer);
    data.fill(65);
    await fs.write(file, data);
    await fs.close(file);

    console.log(await fs.readdir("/"));

    file = await fs.open("/asdf", O_RDONLY);
    console.log(file);

    buffer = new ArrayBuffer(32);
    data = new Uint8Array(buffer);
    await fs.read(file, data);
    console.log(data);

    await fs.close(file);
    return fs;
}

async function test_write_max(){
    fs = new MyFS();
    console.log(await fs.readdir("/").length == 2);
    await fs.open("/asdf", O_CREAT, 0o777);
    file = await fs.open("/asdf", O_WRONLY);
    console.log(file);
    buffer = new ArrayBuffer(fs.max_filesize);
    data = new Uint8Array(buffer);
    data.fill(65);
    await fs.write(file, data);
    await fs.close(file);

    console.log(await fs.readdir("/"));

    file = await fs.open("/asdf", O_RDONLY);
    console.log(file);

    buffer = new ArrayBuffer(fs.max_filesize);
    data = new Uint8Array(buffer);
    await fs.read(file, data);
    console.log(data);

    await fs.close(file);
    return fs;
}

async function test_mkdir() {
    fs = new MyFS();
    await fs.mkdir("/newdir", 0o777);
    await fs.open("/newdir/newfile", O_CREAT, 0o777);
    console.log(await fs.readdir("/"));
    console.log(await fs.readdir("/newdir"));
    return fs;
}

async function test_link() {
    fs = new MyFS();
    var file1 = await fs.open("/newfile", O_CREAT, 0o777);
    var inode2 = await fs.link("/newfile", "/newfile1");
    assert((await fs.readdir("/")).length == 4);
    assert(file1.inode == fs._inodes[inode2]);
    assert(typeof(i1) !== 'string');
    return fs;
}

async function test_unlink() {
    // Depends on test_link
    fs = await test_link();
    await fs.unlink("/newfile");
    dirs = await fs.readdir("/");
    assert(dirs.length == 3);
    assert(dirs[2].filename == "newfile1");
    await fs.unlink("/newfile1");
    dirs = await fs.readdir("/");
    assert(dirs.length == 2);
    return fs;
}

async function test_create() {
    fs = new MyFS();
    await fs.create("/newfile", 0o777);
    var contents = await fs.readdir("/");
    assert(contents.length == 3);
    assert(contents[2].inodenum == 1);
    assert(contents[2].filename == "newfile");
    return fs;
}

async function test_stat() {
    var fs = new MyFS();
    var info = await fs.stat("/");
    assert(info.path == "/");
    assert(info.inodenum == 0);
    assert(info.mode == 0o755, info.mode);
    assert(info.is_directory);
    assert(info.filesize == 0);
    assert(info.atim);
    assert(info.mtim);
    assert(info.ctim);
    return fs;
}

async function test_truncate() {
    var fs = new MyFS();
    var info = null;
    await fs.create("/newfile", 0o777);

    async function trunc_and_check(size) {
        var error = await fs.truncate("/newfile", size);
        info = await fs.stat("/newfile");
        assert(info.filesize == size, info.filesize + "!=" + size);
    }

    await trunc_and_check(fs.block_size);
    await trunc_and_check(fs.max_filesize);
    await trunc_and_check(fs.block_size);
    return fs;
}

async function test_chmod() {
    var fs = new MyFS();
    await fs.create("/newfile", 0o777);
    await fs.chmod("/newfile", 0o444);
    var info = await fs.stat("/newfile");
    assert(info.mode == 0o444);
    return fs;
}

async function test_ioctl() {
    var fs = new MyFS();
    var fd = await fs.open("/", O_RDONLY);
    assert(typeof(await fs.ioctl(fd, IOCTL_SELECT_INODE)) !== 'string');
    assert(typeof(await fs.ioctl(fd, IOCTL_IS_TTY)) === 'string');
    return fs;
}

async function test_seek() {
    var expected_str = "Hello data!";
    var wrong_str = "Jello data!";

    var fs = new MyFS();
    await fs.create("/newfile", 0o777);
    var fd = await fs.open("/newfile", O_RDWR);
    await fs.write(fd, str_to_bytes(wrong_str));
    await fs.seek(fd, 0, SEEK_SET);
    await fs.write(fd, str_to_bytes("H"));
    await fs.seek(fd, 0, SEEK_SET);
    var data = new Uint8Array(new ArrayBuffer(expected_str.length));
    await fs.read(fd, data);
    assert(bytes_to_str(data) === expected_str);
    return fs;
}

</script>
